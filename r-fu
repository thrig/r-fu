#!/usr/bin/env perl
#
# R wrapper script that applies named "arlets" (templated R code plus
# optional configuration files with defaults) against hopefully appropriate
# input data and write the hopefully appropriate output data required from
# running said templated R code through R itself. Basically some glue to
# help make R work better from the unix command line (or Makefile, etc.)
# environment.
#
# Run perldoc(1) on this file for additional documentation.
#
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
use warnings;

use Config::Tiny ();
use File::Basename qw(basename);
use File::HomeDir ();
use File::Slurper qw(read_text);
use File::Spec ();
use File::Temp ();
use Getopt::Long qw(GetOptions);
use IPC::Run3 qw(run3);
use Template::Simple ();

my $Arlet_Dir = $ENV{ARLET_DIR}
  || File::Spec->catfile( File::HomeDir->my_home, "share/arlets" );
my @R_Command =
  qw(R --encoding=UTF-8 --no-restore --no-save --quiet --slave --args);

my $Prog_Name = basename($0);
my $Tmp_Fh;

GetOptions(
  'help|h|?'   => \&emit_help,
  'width=f'    => \my $Flag_Width,
  'height=f'   => \my $Flag_Height,
  'show-code'  => \my $Flag_Show_Code,
) or do { warn "$Prog_Name: error parsing options\n"; emit_help() };

my $arlet = shift // emit_help();
$arlet = File::Spec->catfile( $Arlet_Dir, $arlet );

##############################################################################
#
# MAIN

my $Config = load_config($arlet);

# hmm, but also want auto-filename added if unset and *.ini notes that
# there should be a device file... inject trailing filename in such a
# case, but that would then require mandatory pre-arguments. Hrm!

# Try to be smart about the output format. Remove this if proves
# problematic, replace with `-o pdf` or something?
if ( @ARGV and $ARGV[-1] =~ m/\.([^.]+)$/ ) {
  my $device = $1;
  if (exists $Config->{device}->{ $device . "_width" }) {
    $Config->{device}->{device} = $device;
  }
}

if ( defined $Flag_Width ) {
  $Config->{device}->{ $Config->{device}->{device} . '_width' } = $Flag_Width;
}
if ( defined $Flag_Height ) {
  $Config->{device}->{ $Config->{device}->{device} . '_height' } =
    $Flag_Height;
}

# For `... | r-fu ...` support; stdin is used to feed R code to R, so
# must instead create a temporary file, and inject that filename onto
# the arguments to R as hopefully appropriate. (Another option might be
# to template the data from stdin into the R code directly, but that's
# more work.)
if ( $Config->{_}->{read_stdin} ) {
  if ( !@ARGV ) {
    push @ARGV, stdin2tmpfile();
  } else {
    for my $arg (@ARGV) {
      if ( $arg eq '-' ) {
        $arg = stdin2tmpfile();
        last;
      }
    }
  }
}

my %template;
$template{argcount} = @ARGV;
for my $ai ( 0 .. $#ARGV ) {
  $template{"arg$ai"} = $ARGV[$ai];
}

$template{device} = $Config->{device}->{device};
$template{device_width} =
  $Config->{device}->{ $Config->{device}->{device} . '_width' };
$template{device_height} =
  $Config->{device}->{ $Config->{device}->{device} . '_height' };

my $tmpl = Template::Simple->new();
my $rcode = $tmpl->render( read_text($arlet), \%template );

if ($Flag_Show_Code) {
  print $$rcode;
  exit;
}

my ( $stdout, $stderr );

# in the event the R code in the template wants to call commandArgs
push @R_Command, @ARGV;

# run3 will either blow up, or set something non-zero in $? if something went
# awry, so pass whatever that is along. But do need to show anything from R if
# things go awry for ease of debugging; otherwise remain silent (no news is
# good news).
eval { run3 \@R_Command, $rcode, \$stdout, \$stderr; };
if ($@) {
  warn "$Prog_Name: R command: @R_Command\n";
  warn "$Prog_Name: run3() failed: $@\n";
  exit 1;
}
if ( $? >> 8 != 0 ) {
  warn "$Prog_Name: R command: @R_Command\n";
  warn $stderr;
  $Config->{_}->{hide_stdout} = 0;
}
print $stdout unless $Config->{_}->{hide_stdout};
exit $?;

##############################################################################
#
# SUBROUTINES

sub emit_help {
  warn
    "Usage: $Prog_Name [-o=png|pdf] [--width=f] [--height=f] [--show-code] arlet [arletargs ..]\n";
  exit 64;
}

sub load_config {
  my ($arlet) = @_;

  my $global_conf =
    Config::Tiny->read( File::Spec->catfile( $Arlet_Dir, 'defaults.ini' ),
    'utf8' );

  my $arlet_conf =
    Config::Tiny->read( File::Spec->catfile( $Arlet_Dir, "$arlet.ini" ),
    'utf8' );
  for my $key ( keys %$arlet_conf ) {
    if ( !exists $global_conf->{$key} ) {
      $global_conf->{$key} = $arlet_conf->{$key};
    } else {
      for my $subkey ( keys %{ $arlet_conf->{$key} } ) {
        $global_conf->{$key}->{$subkey} = $arlet_conf->{$key}->{$subkey};
      }
    }
  }

  return $global_conf;
}

sub stdin2tmpfile {
  $Tmp_Fh =
    File::Temp->new( TMPDIR => 1, TEMPLATE => "$Prog_Name.stdin.XXXXXXXXXX" );
  $Tmp_Fh->print($_) while readline STDIN;
  $Tmp_Fh->flush;
  $Tmp_Fh->sync;
  return $Tmp_Fh->filename;
}

__END__

=head1 NAME

r-fu - template and feed named code templates to R

=head1 SYNOPSIS

  $ cat times
  1000 0.0024
  2000 0.0077
  4000 0.0306
  8000 0.1258
  16000 0.4815
  32000 1.8844
  $ r-fu timecomplex times out.pdf

Or, reading from standard input (and temporary files):

  $ r-fu timecomplex - out.pdf < times

Or, to see the code that would be passed to R:

  $ r-fu --show-code timecomplex times out.pdf
  ...

Or then to fuss around with this data in R:

  $ r-fu --show-code timecomplex times out.pdf > rc
  $ R
  > source("rc")
  > ...

=head1 DESCRIPTION

C<r-fu> is a R wrapper script that runs a named "arlet" (templated R code
plus optional configuration files with defaults) through R. Basically some
glue to better integrate R into the unix command line environment.

=head1 USAGE

  $ r-fu [options] arletname [arletargs ..]

This program supports the following command line options:

=over 4

=item B<--output>=I<pdf|png>

Specify the format of the resulting graphic (if any).

=item B<--width>=I<float>

Width of the resulting graphic (if any). Should probably be in units
sensible to the output format (PDF by default, though this may differ on a
per-arlet basis).

=item B<--height>=I<float>

Width of the resulting graphic (if any).

=item B<--show-code>

Does not run R; instead shows the templated R code that would be passed to R
on standard out. This code, as shown in the L</"SYNOPSIS">, above, could
then be read into R, for example.

=back

=head1 ARLETS

Templates to be filled in and passed to R, plus an optional C<*.conf> with
template defaults (e.g. for width and height). These must be located in a
directory that C<r-fu> is configured to look in, set by the C<ARLET_DIR>
environment variable or C<~/share/arlets> otherwise.

L<Template::Simple> is used to template the arlets.

=head2 Config File

Arlets may have an optional C<arletname.ini> file, in addition to the global
C<defaults.ini> from which various parameters may be set, in particular the
default output format, how to handle I/O handles, and so forth.

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this program may be available from:

http://github.com/thrig/r-fu

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

Buggy arlet code will doubtless cause R to blow up in strange ways.

The graphics device prints some random messages, would be nice to find a way
to turn those off, so arlet code could generate both a graph and make
unpolluted output to standard out.

=head1 SEE ALSO

L<http://www.r-project.org/>

Another option for doing R from Perl is L<Statistics::NiceR>.

Other R projects in the same vein include L<http://yihui.name/knitr/> and L<http://www.rstudio.com/>.

=head1 AUTHOR

thrig - Jeremy Mates (cpan:JMATES) C<< <jmates at cpan.org> >>

=head1 COPYRIGHT

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
