#!/usr/bin/env perl
#
# R wrapper script that applies named "arlets" (templated R code plus
# optional configuration files with defaults) against hopefully appropriate
# input data and write the hopefully appropriate output data required from
# running said templated R code through R itself. Basically some glue to
# help make R work better from the unix command line (or Makefile, etc.)
# environment.
#
# Run perldoc(1) on this file for additional documentation.
#
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
use warnings;

use Config::Tiny ();
use File::Basename qw(basename);
use File::HomeDir ();
use File::Slurper qw(read_text);
use File::Spec ();
use File::Temp ();
use Getopt::Long qw(GetOptions);
use IPC::Run3 qw(run3);
# Backwards incompatibility: Xslate proved too HTMLish (always escaping
# things; this is troublesome for not-HTML needs) and Template::Simple
# too, well, simple, as the templates do need some logic (or I need to
# learn a *lot* more about R).
use Text::Template ();

my $Arlet_Dir = $ENV{ARLET_DIR}
  || File::Spec->catfile( File::HomeDir->my_home, "share/arlets" );
my @R_Command =
  qw(R --encoding=UTF-8 --no-restore --no-save --quiet --slave --args);

my $Prog_Name = basename($0);
my $Tmp_Fh;

GetOptions(
  'help|h|?'    => \&emit_help,
  'width=f'     => \my $Flag_Width,
  'height=f'    => \my $Flag_Height,
  'show-code'   => \my $Flag_Show_Code,
  'show-stdout' => \my $Flag_Show_Stdout,
) or do { warn "$Prog_Name: error parsing options\n"; emit_help() };

my $arlet = shift // emit_help();
my $arlet_file = File::Spec->catfile( $Arlet_Dir, $arlet );

die "$Prog_Name: cannot read arlet file '$arlet_file'\n" if !-r $arlet_file;

##############################################################################
#
# MAIN

my $Config = load_config($arlet);

# Try to guess the output format. Remove this if proves problematic,
# perhaps something like `-o pdf` or `-o foo.png` ?
if (@ARGV) {
  for my $arg ( reverse @ARGV ) {
    if ( $arg =~ m/\.([^.]+)$/ ) {
      my $dev = $1;
      # KLUGE test to see if extant format; otherwise would need a list
      # of known formats...
      if ( exists $Config->{device}->{ $dev . "_width" } ) {
        $Config->{device}->{device} = $dev;
      }
      last;
    }
  }
}

if ( defined $Flag_Width ) {
  $Config->{device}->{ $Config->{device}->{device} . '_width' } = $Flag_Width;
}
if ( defined $Flag_Height ) {
  $Config->{device}->{ $Config->{device}->{device} . '_height' } =
    $Flag_Height;
}

if ( defined $Flag_Show_Stdout ) {
  $Config->{_}->{hide_stdout} = 0;
}

# For `... | r-fu ...` support; stdin is used to feed R code to R, so
# must instead create a temporary file, and inject that filename onto
# the arguments to R as hopefully appropriate. (Another option might be
# to template the data from stdin into the R code directly, but that's
# more work.)
if ( $Config->{_}->{read_stdin} ) {
  if ( !@ARGV ) {
    push @ARGV, stdin2tmpfile();
  } else {
    for my $arg (@ARGV) {
      if ( $arg eq '-' ) {
        $arg = stdin2tmpfile();
        last;
      }
    }
  }
}

my $dev      = $Config->{device}->{device};
my %template = (
  args       => \@ARGV,
  arlet      => $arlet,
  arlet_file => $arlet_file,
  device     => $dev,
  width      => $Config->{device}->{ $dev . '_width' },
  height     => $Config->{device}->{ $dev . '_height' },
  Prog_Name  => $Prog_Name,
);

my $tmpl = Text::Template->new( TYPE => 'FILE', SOURCE => $arlet_file );
my $rcode = $tmpl->fill_in( HASH => \%template );

if ($Flag_Show_Code) {
  print $rcode;
  exit;
}

my ( $stdout, $stderr );

# in the event the R code in the template wants to call commandArgs
push @R_Command, @ARGV;

# run3 will either blow up, or set something non-zero in $? if something went
# awry, so pass whatever that is along. But do need to show anything from R if
# things go awry for ease of debugging; otherwise remain silent (no news is
# good news).
eval { run3 \@R_Command, \$rcode, \$stdout, \$stderr; };
if ($@) {
  warn "$Prog_Name: R command: @R_Command\n";
  warn "$Prog_Name: run3() failed: $@\n";
  exit 1;
}
if ( $? >> 8 != 0 ) {
  warn "$Prog_Name: R command: @R_Command\n";
  warn $stderr;
  $Config->{_}->{hide_stdout} = 0;
}
print $stdout unless $Config->{_}->{hide_stdout};
exit $?;

##############################################################################
#
# SUBROUTINES

sub emit_help {
  warn
    "Usage: $Prog_Name [-o=png|pdf] [--width=f] [--height=f] \n",
    "    [--show-code] [--show-stdout] arlet [arletargs ..]\n";
  exit 64;
}

sub load_config {
  my ($arlet) = @_;

  my $global_conf =
    Config::Tiny->read( File::Spec->catfile( $Arlet_Dir, 'defaults.ini' ),
    'utf8' );

  my $arlet_conf =
    Config::Tiny->read( File::Spec->catfile( $Arlet_Dir, "$arlet.ini" ), 'utf8' );
  for my $key ( keys %$arlet_conf ) {
    if ( !exists $global_conf->{$key} ) {
      $global_conf->{$key} = $arlet_conf->{$key};
    } else {
      for my $subkey ( keys %{ $arlet_conf->{$key} } ) {
        $global_conf->{$key}->{$subkey} = $arlet_conf->{$key}->{$subkey};
      }
    }
  }

  return $global_conf;
}

sub stdin2tmpfile {
  $Tmp_Fh =
    File::Temp->new( TMPDIR => 1, TEMPLATE => "$Prog_Name.stdin.XXXXXXXXXX" );
  $Tmp_Fh->unlink_on_destroy(0) if $Flag_Show_Code;
  $Tmp_Fh->print($_) while readline STDIN;
  $Tmp_Fh->flush;
  $Tmp_Fh->sync;
  return $Tmp_Fh->filename;
}

__END__

=head1 NAME

r-fu - template and feed named code templates to R

=head1 SYNOPSIS

  $ cat times
  1000 0.0024
  2000 0.0077
  4000 0.0306
  8000 0.1258
  16000 0.4815
  32000 1.8844
  $ r-fu timecomplex times out.pdf

Or, reading from standard input (and temporary files):

  $ r-fu timecomplex - out.pdf < times

Or, to see the code that would be passed to R:

  $ r-fu --show-code timecomplex times out.pdf
  ...

Or then to fuss around with this data in R:

  $ r-fu --show-code timecomplex times out.pdf > rc
  $ R
  > source("rc")
  > ...

=head1 DESCRIPTION

C<r-fu> is a R wrapper script that runs a named "arlet" (templated R code
plus optional configuration files with defaults) through R. Basically some
glue to better integrate R into the unix command line environment.

=head1 USAGE

  $ r-fu [options] arletname [arletargs ..]

This program supports the following command line options:

=over 4

=item B<--output>=I<pdf|png>

Specify the format of the resulting graphic (if any).

=item B<--width>=I<float>

Width of the resulting graphic (if any). Should probably be in units
sensible to the output format (PDF by default, though this may differ on a
per-arlet basis).

=item B<--height>=I<float>

Width of the resulting graphic (if any).

=item B<--show-code>

Does not run R; instead shows the templated R code that would be passed to R
on standard out. This code, as shown in the L</"SYNOPSIS">, above, could
then be read into R, for example.

=item B<--show-stdout>

Shows the standard output from R. This may be disabled by default in
either the C<defaults.ini> or arlet-specific C<*.ini> configuration.
Enabling it may or may not produce useful information to standard out,
depending on what the arlet does.

=back

=head1 ARLETS

Templates to be filled in and passed to R, plus an optional C<*.conf> with
template defaults (e.g. for width and height). These must be located in a
directory that C<r-fu> is configured to look in, set by the C<ARLET_DIR>
environment variable or C<~/share/arlets> otherwise.

L<Text::Template> is used to template the arlets.

=head2 Config File

Arlets may have an optional C<arletname.ini> file, in addition to the global
C<defaults.ini> from which various parameters may be set, in particular the
default output format, how to handle I/O handles, and so forth.

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this program may be available from:

http://github.com/thrig/r-fu

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

Buggy arlet code will doubtless cause R to blow up in strange ways.

The graphics device prints some random messages, would be nice to find a way
to turn those off, so arlet code could generate both a graph and make
unpolluted output to standard out.

=head1 SEE ALSO

L<http://www.r-project.org/>

Another option for doing R from Perl is L<Statistics::NiceR>.

Other R projects in the same vein include L<http://yihui.name/knitr/> and L<http://www.rstudio.com/>.

=head1 AUTHOR

thrig - Jeremy Mates (cpan:JMATES) C<< <jmates at cpan.org> >>

=head1 COPYRIGHT

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
