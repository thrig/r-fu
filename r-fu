#!/usr/bin/env perl
#
# R wrapper script that applies named "arlets" (templated R code plus optional
# configuration files with defaults) against hopefully appropriate input data
# and write the hopefully appropriate output data required from running said
# templated R code through R itself. Basically some glue to help make R work
# better from the unix command line (or Makefile, etc.) environment.
#
# Run perldoc(1) on this file for additional documentation.
#
# This program is free software; you can redistribute it and/or modify it under
# the same terms as Perl itself.

use strict;
use warnings;

use File::Basename qw(basename);
use File::HomeDir ();
use File::Spec    ();
use File::Temp    ();
use Getopt::Long qw(GetOptions);
use IPC::Run3 qw(run3);
use Text::Xslate ();

my $Arlet_Dir = $ENV{ARLET_DIR}
  || File::Spec->catfile( File::HomeDir->my_home, "share/arlets" );
my @R_Command =
  qw(R --encoding=UTF-8 --no-restore --no-save --quiet --slave --args);

my $Prog_Name = basename($0);
my $Tmp_Fh;

GetOptions(
  'help|h|?'  => \&emit_help,
  'width=f'   => \my $Flag_Width,
  'height=f'  => \my $Flag_Height,
  'show-code' => \my $Flag_Show_Code,
) or do { warn "$Prog_Name: error parsing options\n"; emit_help() };

my $arlet = shift or emit_help();
my $arlet_file = "$arlet.rtmpl";

# Global defaults, clobbered by anything in the (optional!) *.conf file,
# clobbered by anything read somehow as an option.
my %template = ( width => 7, height => 7 );

my $hide_stdout = 0;
my $read_stdin  = 1;

##############################################################################
#
# MAIN

# Should use Config:: something but didn't have any installed on my laptop at
# time of writing nor Internet access, so going with (the predictably buggy)
# "simple INI style in a hurry" method.
{
  my $config;
  if ( open $config, '<', File::Spec->catfile( $Arlet_Dir, "$arlet.conf" ) ) {
    while ( my $line = readline $config ) {
      if ( $line =~ m/^([^=]+)=(.*)/ ) {
        $template{$1} = $2;
      }
    }
    if ( exists $template{no_stdout} ) {
      $hide_stdout = $template{no_stdout};
    }
    if ( exists $template{no_stdin} ) {
      $read_stdin = $template{no_stdin};
    }
  }
}

if ( defined $Flag_Width ) {
  $template{width} = $Flag_Width;
}
if ( defined $Flag_Height ) {
  $template{height} = $Flag_Height;
}

# For `... | r-fu ...` support; stdin used to feed R code to R, so must create
# temporary file, and try to find a conventional "-" to replace with the
# temporary filename for the R code to then presumably read. (Another option
# might be to template the data from stdin into the R code directly, but that's
# more work.)
if ($read_stdin) {
  if ( !@ARGV ) {
    push @ARGV, stdin2tmpfile();
  } else {
    for my $arg (@ARGV) {
      if ( $arg eq '-' ) {
        $arg = stdin2tmpfile();
        last;
      }
    }
  }
}

# Anything remaining past the arlet name passed to template
$template{args} = \@ARGV;

my $tx = Text::Xslate->new( path => [$Arlet_Dir] );
my $rcode = $tx->render( $arlet_file, \%template );

if ($Flag_Show_Code) {
  print $rcode;
  exit;
}

my ( $stdout, $stderr );

# in the event the R code in the template wants to call commandArgs
push @R_Command, @ARGV;

# run3 will either blow up, or set something non-zero in $? if something went
# awry, so pass whatever that is along. But do need to show anything from R if
# things go awry for ease of debugging; otherwise remain silent (no news is
# good news).
eval { run3 \@R_Command, \$rcode, \$stdout, \$stderr; };
if ($@) {
  warn "$Prog_Name: R command: @R_Command\n";
  warn "$Prog_Name: run3() failed: $@\n";
  exit 1;
}
if ( $? >> 8 != 0 ) {
  warn "$Prog_Name: R command: @R_Command\n";
  warn $stderr;
  $hide_stdout = 0;
}
print $stdout unless $hide_stdout;
exit $?;

##############################################################################
#
# SUBROUTINES

sub emit_help {
  warn
    "Usage: $Prog_Name [--width=f] [--height=f] [--show-code] arlet [arletargs ..]";
  exit 64;
}

sub stdin2tmpfile {
  $Tmp_Fh =
    File::Temp->new( TMPDIR => 1, TEMPLATE => "$Prog_Name.stdin.XXXXXXXXXX" );
  $Tmp_Fh->print($_) while readline STDIN;
  $Tmp_Fh->flush;
  $Tmp_Fh->sync;
  return $Tmp_Fh->filename;
}

__END__

=head1 NAME

r-fu - template and feed named code templates to R

=head1 SYNOPSIS

  $ cat times
  1000 0.0024
  2000 0.0077
  4000 0.0306
  8000 0.1258
  16000 0.4815
  32000 1.8844
  $ r-fu timecomplex times out.pdf
  $ open out.pdf

Or, reading from standard input (and temporary files):

  $ r-fu timecomplex - out.pdf < times

Or, to see the code that would be passed to R:

  $ r-fu --show-code timecomplex times out.pdf
  ...

Or, to then fuss around with this data in R:

  $ r-fu --show-code timecomplex times out.pdf > rc
  $ R
  > source("rc")
  > ...

=head1 DESCRIPTION

C<r-fu> is a R wrapper script that runs a named "arlet" (templated R code plus
optional configuration files with defaults) through R. Basically some glue to
help make R work better from the unix command line (or Makefile, etc.)
environment.

=head1 USAGE

  $ r-fu [options] arlet [arletargs ..]

This program supports the following command line switches:

=over 4

=item B<--width>=I<float>

Width of the resulting graph (if any).

=item B<--height>=I<float>

Width of the resulting graph (if any).

=item B<--show-code>

Does not run R; instead shows the templated R code that would be passed to R on
standard out. This code, as shown above, could then be read into an R REPL via
C<source>, for example.

=back

=head1 ARLETS

Templates to be filled in and passed to R, plus an optional C<*.conf> with
template defaults (e.g. for width and height). These must be located in a
directory that C<r-fu> is configured to look in, set by the C<ARLET_DIR>
environment variable or C<~/share/arlets> otherwise.

L<Text::Xslate> is used to template the arlets; see
L<Text::Xslate::Syntax::Kolon> for the template format. The C<arlets> directory
might be good to study as well.

=head2 Config File

Arlets may have an optional C<*.conf> file; this is parsed only for
C<key=value> lines that are added to the template parameters; one exception is
the C<no_stdout> line, which can be set to a "true" value for Perl to hide
standard out from R, which otherwise is shown by default (or under error
conditions):

  no_stdout=1

This is suitable to set for arlets that only produce some graphics file.
Another option determines whether standard input to C<r-fu> is used:

  no_stdin=1

would turn off the default handling of standard input, which is to copy that
data to a temporary file, and if the argument list is empty, append that
filename to the command arguments; or, if the argument list is not empty, the
first C<-> in that list will be replaced with the temporary filename.

=head1 BUGS

=head2 Reporting Bugs

Newer versions of this program may be available from:

http://github.com/thrig/r-fu

If the bug is in the latest version, send a report to the author.
Patches that fix problems or add new features are welcome.

=head2 Known Issues

Buggy arlet code will doubtless cause R to blow up in strange ways. Doubtless
other things besides.

The graphics device prints some random messages, would be nice to find a way to
turn those off, so arlet code could generate both a graph and make unpolluted
output to standard out.

=head1 SEE ALSO

L<http://www.r-project.org/>

Template system for the arlets:

L<Text::Xslate>, <Text::Xslate::Syntax::Kolon> 

Other R projects in the same vein:

L<http://yihui.name/knitr/>

L<http://www.rstudio.com/>

=head1 AUTHOR

thrig - Jeremy Mates (cpan:JMATES) C<< <jmates at cpan.org> >>

=head1 COPYRIGHT

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
